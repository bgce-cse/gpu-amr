// In ndutils
namespace neighbours
{

enum class NeighborRelation : std::uint8_t
{
    Sibling,
    ParentNeighbor,
};

template <std::integral auto Dim, std::integral auto Fanout>
[[nodiscard]]
consteval auto compute_neighbor_relation_maps()
{
    using size_type                = std::common_type_t<decltype(Fanout), decltype(Dim)>;
    static constexpr size_type dim = Dim;
    static constexpr size_type fanout    = Fanout;
    static constexpr size_type nd_fanout = compute_nd_fanout(dim, fanout);
    using neighbor_relation_array_t      = std::array<NeighborRelation, 2 * dim>;
    std::array<neighbor_relation_array_t, nd_fanout> neighbor_relation_maps{};

    for (size_type flat = 0; flat < nd_fanout; ++flat)
    {
        auto& relation_array = neighbor_relation_maps[flat];
        // compute multi-index from flat index
        std::array<size_type, dim> coords{};
        size_type                  remainder = flat;
        for (size_type d = 0; d < dim; ++d)
        {
            coords[d] = remainder % fanout;
            remainder /= fanout;
        }
        for (size_type d = 0; d < dim; ++d)
        {
            // - direction
            relation_array[2 * d] = (coords[d] == 0) ? NeighborRelation::ParentNeighbor
                                                     : NeighborRelation::Sibling;
            // + direction
            relation_array[2 * d + 1] = (coords[d] == fanout - 1)
                                            ? NeighborRelation::ParentNeighbor
                                            : NeighborRelation::Sibling;
        }
    }
    return neighbor_relation_maps;
}

}

// In ndtree
    auto compute_parent_neighbors(patch_index_t child_id) -> neighbor_array_t
    {
        std::cout << "\n=== COMPUTING PARENT NEIGHBORS ===" << std::endl;
        std::cout << "Child ID: " << child_id.id() << std::endl;

        auto parent_id = patch_index_t::parent_of(child_id);
        std::cout << "Parent ID: " << parent_id.id() << std::endl;

        neighbor_array_t parent_neighbor_array{};
        const char*      direction_names[] = { "-X", "+X", "-Y", "+Y" };

        // Iterate over all directions
        for (std::size_t direction = 0; direction < 2 * s_dimension; direction++)
        {
            std::cout << "\n--- Direction " << direction_names[direction] << " (index "
                      << direction << ") ---" << std::endl;

            // Get the relevant child index in that direction
            std::size_t direction_dim = direction / 2; // 0=x, 1=y for 2D //
            bool        positive =
                (direction % 2) == 1; // true for +direction, false for -direction

            // Get child coordinates at the boundary face
            std::vector<patch_index_t> boundary_children;

            for (std::size_t i = 0; i != s_nd_fanout; i++)
            {
                auto local_multi_index = static_child_layout_t::multi_index(i);

                // Check if this child is on the boundary face for this direction
                const bool on_boundary = on_boundary =
                    (local_multi_index[direction_dim] ==
                     (positive ? s_1d_fanout - 1 : 0));

                if (on_boundary)
                {
                    boundary_children.emplace_back(patch_index_t::child_of(parent_id, i));
                }
            }

            std::cout << "  Boundary children: ";
            for (const auto& bc : boundary_children)
            {
                std::cout << bc.id() << " ";
            }
            std::cout << std::endl;

            // Get the neighbor of the first boundary child to determine the pattern
            auto first_child_it = find_index(boundary_children[0]);
            assert(first_child_it.has_value());
            auto first_child_neighbors = m_neighbors[first_child_it.value()->second];
            auto first_child_neighbor  = first_child_neighbors[direction];

            std::cout << "  First child neighbor variant index: "
                      << first_child_neighbor.data.index() << std::endl;

            // Distinguish two cases
            std::visit(
                [&](auto&& neighbor)
                {
                    using Neighbor_T = std::decay_t<decltype(neighbor)>;

                    if constexpr (std::is_same_v<
                                      Neighbor_T,
                                      typename NeighborVariant::None>)
                    {
                        std::cout << "  Case: Boundary -> Parent gets NONE" << std::endl;
                        // Boundary case
                        NeighborVariant nb;
                        nb.data = typename NeighborVariant::None{};
                        parent_neighbor_array[direction] = nb;
                    }
                    else if constexpr (std::is_same_v<
                                           Neighbor_T,
                                           typename NeighborVariant::Same>)
                    {
                        std::cout << "  Case: Children have SAME level neighbors -> "
                                     "Parent gets FINER"
                                  << std::endl;

                        // First case: neighbor on child's same level
                        // Add finer level neighbor to neighbor array
                        // Gather fine ids from child neighbors in that direction
                        std::array<patch_index_t, NeighborVariant::s_num_fine>
                            finer_ids{};

                        for (size_t i = 0; i < boundary_children.size(); i++)
                        {
                            auto child_it = find_index(boundary_children[i]);
                            assert(child_it.has_value());
                            auto child_neighbors = m_neighbors[child_it.value()->second];
                            auto child_neighbor  = child_neighbors[direction];

                            // Extract the same-level neighbor ID
                            std::visit(
                                [&](auto&& child_nb)
                                {
                                    using ChildNeighbor_T =
                                        std::decay_t<decltype(child_nb)>;
                                    if constexpr (std::is_same_v<
                                                      ChildNeighbor_T,
                                                      typename NeighborVariant::Same>)
                                    {
                                        finer_ids[i] = child_nb.id;
                                        std::cout << "    Fine neighbor " << i << ": "
                                                  << child_nb.id.id() << std::endl;
                                    }
                                },
                                child_neighbor.data
                            );
                        }

                        NeighborVariant nb;
                        nb.data = typename NeighborVariant::Finer{ finer_ids };
                        parent_neighbor_array[direction] = nb;
                    }
                    else if constexpr (std::is_same_v<
                                           Neighbor_T,
                                           typename NeighborVariant::Coarser>)
                    {
                        std::cout << "  Case: Children have COARSER neighbor -> Parent "
                                     "gets SAME"
                                  << std::endl;

                        // Second case: neighbor on child's coarser level
                        // Easy just copy this neighbor id as type Same
                        NeighborVariant nb;
                        nb.data = typename NeighborVariant::Same{ neighbor.id };
                        parent_neighbor_array[direction] = nb;

                        std::cout << "  -> Assigned SAME neighbor: " << neighbor.id.id()
                                  << std::endl;
                    }
                    else
                    {
                        std::cout
                            << "  ERROR: Unexpected neighbor type during recombination!"
                            << std::endl;
                        assert(
                            false && "Children should not have Finer neighbors during "
                                     "recombination"
                        );
                    }
                },
                first_child_neighbor.data
            );
        }

        std::cout << "\n=== PARENT NEIGHBOR COMPUTATION COMPLETE ===" << std::endl;
        return parent_neighbor_array;
    }

    auto compute_child_neighbors(patch_index_t parent_id, size_t local_child_id)
        -> neighbor_array_t
    {
        std::cout << "\n=== COMPUTING CHILD NEIGHBORS ===" << std::endl;
        std::cout << "Parent ID: " << parent_id.id()
                  << ", Local Child ID: " << local_child_id << std::endl;

        auto parent_it = find_index(parent_id);
        assert(parent_it.has_value() && "Parent must exist in the tree");
        linear_index_t parent_linear_idx = parent_it.value()->second;
        std::cout << "Parent linear index: " << parent_linear_idx << std::endl;

        auto local_multiindex = static_child_layout_t::multi_index(local_child_id);
        std::cout << "Child multi-index: [" << local_multiindex[0] << ", "
                  << local_multiindex[1] << "]" << std::endl;

        auto             relations = s_neighbor_relation_maps[local_child_id];
        neighbor_array_t child_neighbor_array{};
        neighbor_array_t parent_neighbor_array = m_neighbors[parent_linear_idx];

        const char* direction_names[] = { "-X", "+X", "-Y", "+Y" };

        for (size_t direction = 0; direction < 2 * s_dimension; direction++)
        {
            std::cout << "\n--- Direction " << direction_names[direction] << " (index "
                      << direction << ") ---" << std::endl;

            auto directional_relation = relations[direction];
            std::cout << "Relation type: "
                      << (directional_relation ==
                                  amr::ndt::utils::NeighborRelation::Sibling
                              ? "Sibling"
                              : "ParentNeighbor")
                      << std::endl;

            if (directional_relation == amr::ndt::utils::NeighborRelation::Sibling)
            {
                auto sibling_offset = get_sibling_offset(local_child_id, direction);
                auto sibling_id     = patch_index_t::child_of(parent_id, sibling_offset);

                std::cout << "  Sibling offset: " << sibling_offset
                          << ", Sibling ID: " << sibling_id.id() << std::endl;

                NeighborVariant nb;
                nb.data = typename NeighborVariant::Same{ sibling_id };
                child_neighbor_array[direction] = nb;

                std::cout << "  -> Assigned SAME neighbor: " << sibling_id.id()
                          << std::endl;
            }
            else
            {
                NeighborVariant parent_directional_neighbor =
                    parent_neighbor_array[direction];
                std::cout << "  Parent neighbor variant index: "
                          << parent_directional_neighbor.data.index() << std::endl;

                std::visit(
                    [&](auto&& neighbor)
                    {
                        using Neighbor_T = std::decay_t<decltype(neighbor)>;

                        if constexpr (std::is_same_v<
                                          Neighbor_T,
                                          typename NeighborVariant::None>)
                        {
                            std::cout << "  Parent has NONE neighbor -> Child gets NONE"
                                      << std::endl;

                            NeighborVariant nb;
                            nb.data = typename NeighborVariant::None{};
                            child_neighbor_array[direction] = nb;
                        }
                        else if constexpr (std::is_same_v<
                                               Neighbor_T,
                                               typename NeighborVariant::Same>)
                        {
                            std::cout
                                << "  Parent has SAME neighbor (ID: " << neighbor.id.id()
                                << ") -> Child gets COARSER" << std::endl;

                            NeighborVariant nb;

                            if constexpr (requires { neighbor.id; })
                            {
                                nb.data =
                                    typename NeighborVariant::Coarser{ neighbor.id };
                                std::cout << "  -> Assigned COARSER neighbor: "
                                          << neighbor.id.id() << std::endl;
                            }
                            child_neighbor_array[direction] = nb;
                        }
                        else if constexpr (std::is_same_v<
                                               Neighbor_T,
                                               typename NeighborVariant::Finer>)
                        {
                            std::cout << "  Parent has FINER neighbors -> Child gets "
                                         "specific SAME neighbor"
                                      << std::endl;

                            size_t direction_dim  = direction / 2; // 0=x, 1=y for 2D
                            size_t relevant_coord = 0;
                            if constexpr (s_dimension == 2)
                            {
                                relevant_coord =
                                    local_multiindex[(direction_dim + 1) % s_dimension];
                                std::cout << "    Direction dim: " << direction_dim
                                          << ", Relevant coord: " << relevant_coord
                                          << std::endl;
                            }
                            else
                            {
                                assert(false);
                            }

                            // Print all fine neighbors
                            std::cout << "    Fine neighbors: [";
                            for (size_t i = 0; i < neighbor.ids.size(); i++)
                            {
                                std::cout << neighbor.ids[i].id();
                                if (i < neighbor.ids.size() - 1) std::cout << ", ";
                            }
                            std::cout << "]" << std::endl;

                            auto fine_neighbor_id = neighbor.ids[relevant_coord];
                            std::cout
                                << "    Selected fine neighbor: " << fine_neighbor_id.id()
                                << std::endl;

                            NeighborVariant nb;
                            nb.data = typename NeighborVariant::Same{ fine_neighbor_id };
                            child_neighbor_array[direction] = nb;

                            std::cout << "  -> Assigned SAME neighbor: "
                                      << fine_neighbor_id.id() << std::endl;
                        }
                        else if constexpr (std::is_same_v<
                                               Neighbor_T,
                                               typename NeighborVariant::Coarser>)
                        {
                            std::cout << "  ERROR: Parent has COARSER neighbor but "
                                         "trying to refine!"
                                      << std::endl;
                            assert(
                                false && "sth isogin wrong as your neighbro is coarser "
                                         "and u try to refine my friend"
                            );
                        }
                        else
                        {
                            std::cout << "  ERROR: Unknown neighbor variant type!"
                                      << std::endl;
                            assert(false && "Unknown neighbor variant type");
                        }
                    },
                    parent_directional_neighbor.data
                );
            }
        }

        std::cout << "\n=== CHILD NEIGHBOR COMPUTATION COMPLETE ===" << std::endl;
        return child_neighbor_array;
    }

    typename patch_index_t::offset_t
        get_sibling_offset(size_t local_child_id, size_t direction) const
    {
        // Convert local_child_id to coordinates
        std::array<typename patch_index_t::offset_t, s_dimension> coords{};
        size_t remainder = local_child_id;
        for (size_t d = 0; d < s_dimension; ++d)
        {
            coords[d] = remainder % s_1d_fanout;
            remainder /= s_1d_fanout;
        }

        // Calculate sibling coordinates based on direction
        size_t dim    = direction / 2;        // Which dimension (0=x, 1=y)
        bool positive = (direction % 2) == 1; // true for +direction, false for -direction

        if (positive)
        {
            coords[dim] = (coords[dim] + 1) % s_1d_fanout;
        }
        else
        {
            coords[dim] = (coords[dim] + s_1d_fanout - 1) % s_1d_fanout;
        }

        // Convert back to flat index
        typename patch_index_t::offset_t result     = 0;
        typename patch_index_t::offset_t multiplier = 1;
        for (size_t d = 0; d < s_dimension; ++d)
        {
            result += coords[d] * multiplier;
            multiplier *= s_1d_fanout;
        }

        return result;
    }

    // Helper function to get specific fine neighbors for a child
    patch_index_t get_fine_neighbors_for_child(
        const std::array<patch_index_t, NeighborVariant::s_num_fine>& fine_neighbors,
        size_t                                                        local_child_id,
        size_t                                                        direction
    ) const
    {
        auto relevant_coord = local_child_id / s_1d_fanout * (direction / 2);

        std::array<size_t, s_dimension> coords{};
        size_t                          remainder = local_child_id;
        for (size_t d = 0; d < s_dimension; ++d)
        {
            coords[d] = remainder % s_1d_fanout;
            remainder /= s_1d_fanout;
        }
        return fine_neighbors[relevant_coord];
    }

    void enforce_symmetric_neighbors(
        patch_index_t     patch_id,
        neighbor_array_t& neighbor_array
    )
    {
        std::cout << "\n=== ENFORCING SYMMETRIC NEIGHBORS ===" << std::endl;
        std::cout << "Patch ID: " << patch_id.id() << std::endl;
        for (size_t direction = 0; direction < 2 * s_dimension; direction++)
        {
            auto& neighbor_variant = neighbor_array[direction]; // retrieve variant

            // Calculate opposite direction
            size_t opposite_direction;
            if (direction % 2 == 0)
            {
                opposite_direction = direction + 1; // -x -> +x, -y -> +y
            }
            else
            {
                opposite_direction = direction - 1; // +x -> -x, +y -> -y
            }

            const char* direction_names[] = { "-X", "+X", "-Y", "+Y" };
            std::cout << "\n--- Direction " << direction_names[direction]
                      << " (opposite: " << direction_names[opposite_direction] << ") ---"
                      << std::endl;
            std::cout << "Neighbor variant index: " << neighbor_variant.data.index()
                      << std::endl;

            // Handle different neighbor types
            std::visit(
                [&](auto&& neighbor)
                {
                    using Neighbor_T = std::decay_t<decltype(neighbor)>;

                    if constexpr (std::is_same_v<
                                      Neighbor_T,
                                      typename NeighborVariant::None>)
                    {
                        std::cout << "  NONE neighbor - nothing to enforce" << std::endl;
                        // No neighbor - nothing to enforce
                        return;
                    }
                    else if constexpr (std::is_same_v<
                                           Neighbor_T,
                                           typename NeighborVariant::Same>)
                    {
                        std::cout << "  SAME neighbor (ID: " << neighbor.id.id()
                                  << ") - enforcing single symmetry" << std::endl;
                        // Single same-level neighbor
                        enforce_neighbor_symmetry_single(
                            patch_id, neighbor.id, opposite_direction
                        );
                    }
                    else if constexpr (std::is_same_v<
                                           Neighbor_T,
                                           typename NeighborVariant::Coarser>)
                    {
                        std::cout << "  COARSER neighbor (ID: " << neighbor.id.id()
                                  << ") - enforcing coarser symmetry" << std::endl;
                        // Single coarser neighbor - patch_id should appear in the coarser
                        // neighbor's Finer list
                        enforce_neighbor_symmetry_coarser(
                            patch_id, neighbor.id, opposite_direction
                        );
                    }
                    else if constexpr (std::is_same_v<
                                           Neighbor_T,
                                           typename NeighborVariant::Finer>)
                    {
                        // Several Finer neighbor
                        enforce_neighbor_symmetry_finer(
                            patch_id, neighbor.ids, opposite_direction
                        );
                    }
                    else
                    {
                        std::cout << "  ERROR: Unknown neighbor variant type!"
                                  << std::endl;
                        assert(false);
                    }
                },
                neighbor_variant.data
            );
        }

        std::cout << "\n=== SYMMETRIC NEIGHBOR ENFORCEMENT COMPLETE ===" << std::endl;
    }

private:
    // Helper function for same-level neighbor symmetry
    void enforce_neighbor_symmetry_single(
        patch_index_t patch_id,
        patch_index_t neighbor_id,
        size_t        opposite_direction
    )
    {
        std::cout << "    [SINGLE] Enforcing symmetry between patch " << patch_id.id()
                  << " and neighbor " << neighbor_id.id() << std::endl;

        auto neighbor_it = find_index(neighbor_id);
        if (!neighbor_it.has_value())
        {
            std::cout << "    [SINGLE] ERROR: Neighbor " << neighbor_id.id()
                      << " not found in tree!" << std::endl;
            assert(false);
        }

        linear_index_t neighbor_linear_idx     = neighbor_it.value()->second;
        auto&          neighbor_neighbor_array = m_neighbors[neighbor_linear_idx];

        std::cout << "    [SINGLE] Neighbor linear index: " << neighbor_linear_idx
                  << std::endl;
        std::cout << "    [SINGLE] Current neighbor's opposite direction variant index: "
                  << neighbor_neighbor_array[opposite_direction].data.index()
                  << std::endl;

        // Always overwrite with correct symmetry
        NeighborVariant nb;
        nb.data = typename NeighborVariant::Same{ patch_id };
        neighbor_neighbor_array[opposite_direction] = nb;

        std::cout << "    [SINGLE] -> Set neighbor " << neighbor_id.id()
                  << " to have SAME neighbor " << patch_id.id()
                  << " in opposite direction" << std::endl;
    }

    // Helper function for coarser neighbor symmetry
    void enforce_neighbor_symmetry_coarser(
        patch_index_t patch_id,
        patch_index_t coarser_neighbor_id,
        size_t        opposite_direction
    )
    {
        std::cout << "    [COARSER] Enforcing coarser symmetry for patch "
                  << patch_id.id() << " with coarser neighbor "
                  << coarser_neighbor_id.id() << std::endl;

        auto patch_local_offset = patch_index_t::offset_of(patch_id);
        auto multi_index        = static_child_layout_t::multi_index(patch_local_offset);

        std::cout << "    [COARSER] Patch local offset: " << patch_local_offset
                  << ", multi-index: [" << multi_index[0] << ", " << multi_index[1] << "]"
                  << std::endl;

        auto neighbor_it = find_index(coarser_neighbor_id);
        if (!neighbor_it.has_value())
        {
            std::cout << "    [COARSER] ERROR: Coarser neighbor "
                      << coarser_neighbor_id.id() << " not found in tree!" << std::endl;
            assert(false);
        }

        linear_index_t neighbor_linear_idx     = neighbor_it.value()->second;
        auto&          neighbor_neighbor_array = m_neighbors[neighbor_linear_idx];

        std::cout << "    [COARSER] Coarser neighbor linear index: "
                  << neighbor_linear_idx << std::endl;
        std::cout << "    [COARSER] Current coarser neighbor's opposite direction "
                     "variant index: "
                  << neighbor_neighbor_array[opposite_direction].data.index()
                  << std::endl;

        // FIXED: Fill ALL fine neighbors on the boundary face
        std::array<patch_index_t, NeighborVariant::s_num_fine> finer_ids{};

        // Get the parent of patch_id to find all siblings on the boundary
        auto parent_id = patch_index_t::parent_of(patch_id);
        std::cout << "    [COARSER] Parent ID: " << parent_id.id() << std::endl;

        // Determine which coordinate is parallel to the boundary (the one that varies)
        size_t direction_dim = opposite_direction / 2; // 0=x, 1=y for 2D
        size_t parallel_dim =
            (direction_dim + 1) % s_dimension; // The perpendicular dimension

        std::cout << "    [COARSER] Direction dim: " << direction_dim
                  << ", Parallel dim: " << parallel_dim << std::endl;

        // Fill all fine neighbors along the boundary face
        std::cout << "    [COARSER] Creating fine neighbors: [";
        for (size_t i = 0; i < s_1d_fanout; i++)
        {
            // Create coordinates for each sibling on the boundary
            std::array<typename patch_index_t::offset_t, s_dimension> sibling_coords{};

            // Copy the fixed coordinate from our patch
            sibling_coords[direction_dim] = multi_index[direction_dim];

            // Vary the parallel coordinate
            sibling_coords[parallel_dim] =
                static_cast<typename patch_index_t::offset_t>(i);

            std::cout << "(" << sibling_coords[0] << "," << sibling_coords[1] << ")";

            // Convert back to flat index
            typename patch_index_t::offset_t sibling_offset = 0;
            typename patch_index_t::offset_t multiplier     = 1;
            for (size_t d = 0; d < s_dimension; ++d)
            {
                sibling_offset += sibling_coords[d] * multiplier;
                multiplier *= s_1d_fanout;
            }

            // Get the sibling patch ID
            auto sibling_id = patch_index_t::child_of(parent_id, sibling_offset);
            finer_ids[i]    = sibling_id;

            std::cout << "->ID:" << sibling_id.id();
            if (i < s_1d_fanout - 1) std::cout << ", ";
        }
        std::cout << "]" << std::endl;

        NeighborVariant nb;
        nb.data = typename NeighborVariant::Finer{ finer_ids };
        neighbor_neighbor_array[opposite_direction] = nb;

        std::cout << "    [COARSER] -> Set coarser neighbor " << coarser_neighbor_id.id()
                  << " to have FINER neighbors in opposite direction" << std::endl;
    }

    void enforce_neighbor_symmetry_finer(
        patch_index_t                                                 patch_id,
        const std::array<patch_index_t, NeighborVariant::s_num_fine>& finer_neighbor_ids,
        size_t                                                        opposite_direction
    )
    {
        std::cout << "    [FINER] Enforcing finer symmetry for patch " << patch_id.id()
                  << " with finer neighbors" << std::endl;

        // Print all finer neighbor IDs
        std::cout << "    [FINER] Finer neighbor IDs: [";
        for (size_t i = 0; i < finer_neighbor_ids.size(); i++)
        {
            if (finer_neighbor_ids[i].id() != 0)
            { // Skip invalid/empty IDs
                std::cout << finer_neighbor_ids[i].id();
                if (i < finer_neighbor_ids.size() - 1) std::cout << ", ";
            }
        }
        std::cout << "]" << std::endl;

        // Each finer neighbor should have patch_id as its Coarser neighbor
        for (const auto& finer_neighbor_id : finer_neighbor_ids)
        {
            if (finer_neighbor_id.id() == 0)
            { // Skip invalid/empty IDs
                continue;
            }

            std::cout << "    [FINER] Processing finer neighbor: "
                      << finer_neighbor_id.id() << std::endl;

            auto neighbor_it = find_index(finer_neighbor_id);
            if (!neighbor_it.has_value())
            {
                std::cout << "    [FINER] WARNING: Finer neighbor "
                          << finer_neighbor_id.id()
                          << " not found in tree (may not exist yet)" << std::endl;
                continue; // Skip if neighbor doesn't exist yet
            }

            linear_index_t neighbor_linear_idx     = neighbor_it.value()->second;
            auto&          neighbor_neighbor_array = m_neighbors[neighbor_linear_idx];

            std::cout << "    [FINER] Finer neighbor linear index: "
                      << neighbor_linear_idx << std::endl;
            std::cout << "    [FINER] Current finer neighbor's opposite direction "
                         "variant index: "
                      << neighbor_neighbor_array[opposite_direction].data.index()
                      << std::endl;

            // Always overwrite with Coarser neighbor
            NeighborVariant nb;
            nb.data = typename NeighborVariant::Coarser{ patch_id };
            neighbor_neighbor_array[opposite_direction] = nb;

            std::cout << "    [FINER] -> Set finer neighbor " << finer_neighbor_id.id()
                      << " to have COARSER neighbor " << patch_id.id()
                      << " in opposite direction" << std::endl;
        }
    }
